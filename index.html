<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AmpDialer - Amplifire Console</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; padding: 20px; background-color: #f4f4f9; color: #333; }
        .container { max-width: 600px; margin: 0 auto; background: white; padding: 25px; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
        h2 { margin-top: 0; color: #e67e22; }
        .input-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: 600; color: #555; }
        input { width: 100%; padding: 10px; box-sizing: border-box; border: 1px solid #ddd; border-radius: 5px; font-size: 14px; }
        button { padding: 12px 20px; cursor: pointer; border: none; border-radius: 5px; font-size: 16px; margin-right: 10px; font-weight: bold; transition: background 0.2s; }
        button:disabled { opacity: 0.6; cursor: not-allowed; }
        
        #btn-connect { background-color: #3498db; color: white; }
        #btn-dial { background-color: #2ecc71; color: white; }
        #btn-hangup { background-color: #e74c3c; color: white; }

        #output { margin-top: 25px; padding: 15px; background: #1e1e1e; color: #00ff00; height: 350px; overflow-y: auto; font-family: "Consolas", monospace; border-radius: 5px; font-size: 13px; line-height: 1.4; }
        .status-bar { background: #ecf0f1; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #bdc3c7; }
        hr { border: 0; border-top: 1px solid #eee; margin: 25px 0; }
    </style>
</head>
<body>

<div class="container">
    <h2>üî• AmpDialer</h2>

    <div class="status-bar">
        <div class="input-group">
            <label>Login ID (Extension@Domain)</label>
            <input type="text" id="rl-username" placeholder="e.g. 101@291565" value="101@291565">
        </div>
        <div class="input-group">
            <label>Password</label>
            <input type="password" id="rl-password" placeholder="SIP Password">
        </div>
        <button id="btn-connect">Step 1: Connect</button>
    </div>

    <hr>

    <div class="input-group">
        <label>Destination Number</label>
        <input type="text" id="dest-number" placeholder="1234567890">
    </div>
    
    <div>
        <button id="btn-dial" disabled>Step 2: Dial</button>
        <button id="btn-hangup" disabled>Hangup</button>
    </div>

    <div id="output"></div>
    <audio id="remoteAudio" autoplay></audio>
</div>

<script src="sip-0.21.2.min.js"></script>

<script>
    // ============================================================
    // üõ†Ô∏è RUNTIME PARSER PATCH (THE FIX)
    // ============================================================
    // This wrapper tricks the SIP.js parser into accepting "291565"
    // by temporarily changing it to "291565.com" during validation.
    if (window.SIP && SIP.Grammar) {
        console.log("Applying Runtime Patch to SIP.Grammar...");
        const originalParse = SIP.Grammar.parse;
        
        SIP.Grammar.parse = function(input, startRule) {
            try {
                // Try standard parsing first
                return originalParse(input, startRule);
            } catch (e) {
                // If parsing fails, check if it's our numeric domain issue
                if (typeof input === 'string' && input.includes('291565')) {
                    // Create a fake valid domain
                    const fakeInput = input.replace(/291565/g, '291565.com');
                    try {
                        const result = originalParse(fakeInput, startRule);
                        
                        // Fix the result (remove .com)
                        if (result && result.host === '291565.com') result.host = '291565';
                        if (result && result.uri && result.uri.host === '291565.com') result.uri.host = '291565';
                        
                        return result;
                    } catch (e2) { throw e; } // If it still fails, throw original error
                }
                throw e;
            }
        };
    } else {
        alert("CRITICAL: SIP.js failed to load. Restore the original .js file!");
    }

    // ============================================================
    // CONFIGURATION
    // ============================================================
    const WS_SERVER = "wss://core2-mia.ringlogix.com:9002"; 
    const USER_AGENT_STRING = "SNAP.GO Webphone 44.2.2 (Chrome 143.0.0.0)";

    // UI References
    const outputDiv = document.getElementById("output");
    const btnConnect = document.getElementById("btn-connect");
    const btnDial = document.getElementById("btn-dial");
    const btnHangup = document.getElementById("btn-hangup");
    const inputLogin = document.getElementById("rl-username");
    const inputPassword = document.getElementById("rl-password");
    const inputDest = document.getElementById("dest-number");
    const remoteAudio = document.getElementById("remoteAudio");

    let userAgent = null;
    let registerer = null;
    let currentSession = null;

    function log(msg, type = "info") {
        const timestamp = new Date().toLocaleTimeString();
        const el = document.createElement("div");
        el.innerText = `[${timestamp}] ${msg}`;
        if (type === "error") el.style.color = "#ff6b6b"; 
        if (type === "success") el.style.color = "#51cf66"; 
        if (type === "warning") el.style.color = "#fcc419";
        outputDiv.appendChild(el);
        outputDiv.scrollTop = outputDiv.scrollHeight; 
        console.log(msg);
    }

    // ============================================================
    // CONNECT LOGIC
    // ============================================================
    async function connectToPBX() {
        const loginStr = inputLogin.value.trim(); 
        const password = inputPassword.value.trim();

        if (!loginStr || !password) return log("‚ùå Enter Login & Password", "error");

        const parts = loginStr.split('@');
        if (parts.length !== 2) return log("‚ùå Invalid Login Format", "error");

        const userExt = parts[0].trim();       
        const tenantDomain = parts[1].trim();  
        const deviceUser = `${userExt}wp`; // 101wp

        // Identity: sip:101wp@291565
        const identityUri = `sip:${deviceUser}@${tenantDomain}`;
        
        log(`üîπ Identity: ${identityUri}`);

        // Construct URI
        let mySipUri;
        try {
            // Using the constructor directly (Patch handles the rest)
            mySipUri = new SIP.URI("sip", deviceUser, tenantDomain);
        } catch (e) {
            log(`‚ùå URI Error: ${e}`, "error");
            return;
        }

        userAgent = new SIP.UserAgent({
            uri: mySipUri,
            displayName: "AmpDialer",
            
            authorizationUsername: identityUri, 
            authorizationPassword: password,

            transportOptions: { server: WS_SERVER },
            contactName: deviceUser,
            hackIpInContact: true,
            userAgentString: USER_AGENT_STRING,
            logLevel: "debug"
        });

        setupEventHandlers();

        try {
            await userAgent.start();
            log("‚úÖ SIP Agent Started. Connecting...", "info");
            btnConnect.disabled = true;
            btnConnect.innerText = "Connecting...";
        } catch (err) {
            log(`‚ùå Error starting SIP Agent: ${err}`, "error");
            btnConnect.disabled = false;
        }
    }

    function setupEventHandlers() {
        userAgent.transport.stateChange.addListener((state) => {
            log(`üì° Transport State: ${state}`);
            if (state === SIP.TransportState.Connected) {
                log("‚úÖ WebSocket Connected! Registering...", "success");
                registerDevice();
            } else if (state === SIP.TransportState.Disconnected) {
                log("‚ö†Ô∏è WebSocket Disconnected", "error");
                resetUI();
            }
        });

        userAgent.delegate = {
            onInvite: (invitation) => {
                log("üìû Incoming Call...");
                handleCallSession(invitation);
            }
        };
    }

    function registerDevice() {
        registerer = new SIP.Registerer(userAgent);

        registerer.stateChange.addListener((state) => {
            log(`üìù Registration State: ${state}`);
            
            if (state === SIP.RegistererState.Registered) {
                log("‚úÖ DEVICE REGISTERED! READY TO CALL.", "success");
                btnConnect.innerText = "Connected";
                btnDial.disabled = false;
                btnHangup.disabled = true;
            } else if (state === SIP.RegistererState.Terminated) {
                log("‚ö†Ô∏è Registration Terminated. Check Password.", "warning");
            }
        });

        registerer.register()
            .catch((error) => {
                log(`‚ùå Registration Failed: ${error}`, "error");
            });
    }

    async function makeCall() {
        if (!userAgent || !userAgent.transport.isConnected()) return log("‚ùå Not Connected.", "error");

        const dest = inputDest.value.trim();
        if (!dest) return log("‚ùå Enter a number.", "error");

        const tenantDomain = inputLogin.value.split('@')[1].trim();
        log(`üìû Dialing ${dest}...`);

        let target;
        try {
            target = new SIP.URI("sip", dest, tenantDomain);
        } catch(e) {
             // Fallback for dialing if constructor throws
             target = SIP.UserAgent.makeURI(`sip:${dest}@${tenantDomain}`);
        }

        const inviter = new SIP.Inviter(userAgent, target, {
            sessionDescriptionHandlerOptions: { constraints: { audio: true, video: false } }
        });

        handleCallSession(inviter);

        inviter.invite().catch((e) => log(`‚ùå Invite Failed: ${e}`, "error"));
    }

    function handleCallSession(session) {
        currentSession = session;
        btnDial.disabled = true;
        btnHangup.disabled = false;

        session.stateChange.addListener((state) => {
            log(`Call State: ${state}`);
            if (state === SIP.SessionState.Established) {
                log("üó£Ô∏è Call Connected!", "success");
                setupRemoteMedia(session);
            } else if (state === SIP.SessionState.Terminated) {
                log("Call Ended");
                cleanupCall();
            }
        });
    }

    function setupRemoteMedia(session) {
        const remoteStream = new MediaStream();
        session.sessionDescriptionHandler.peerConnection.getReceivers().forEach((receiver) => {
            if (receiver.track) remoteStream.addTrack(receiver.track);
        });
        remoteAudio.srcObject = remoteStream;
        remoteAudio.play().catch(e => log("‚ö†Ô∏è Click page to enable audio"));
    }

    function cleanupCall() {
        currentSession = null;
        btnDial.disabled = false;
        btnHangup.disabled = true;
    }

    function hangupCall() {
        if (!currentSession) return;
        if (currentSession.state === SIP.SessionState.Established) currentSession.bye();
        else if (currentSession.state === SIP.SessionState.Establishing) currentSession.cancel();
    }

    function resetUI() {
        btnConnect.disabled = false;
        btnConnect.innerText = "Step 1: Connect";
        btnDial.disabled = true;
        btnHangup.disabled = true;
    }

    btnConnect.addEventListener("click", connectToPBX);
    btnDial.addEventListener("click", makeCall);
    btnHangup.addEventListener("click", hangupCall);
</script>
</body>
</html>
